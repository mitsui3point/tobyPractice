# 토비의 스프링

[1장-오브젝트와 의존 관계](#1장-오브젝트와-의존-관계)\
[2장-테스트](#2장-테스트)\
[3장-템플릿](#3장-템플릿)

# 1장-오브젝트와 의존 관계

```
1장에서는 사용자 정보를 DB에 등록하거나 아이디로 조회하는 기능을 가진 간단한 DAO 코드를 만들고,
그 코드의 문제점을 살펴본 뒤,
이를 다양한 방법과 패턴, 원칙, IoC/DI 프레임워크까지 적용해서 개선해왔다.

그 과정을 돌아보자.
```

> - 먼저 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다.\
> - 그 중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고,
>   다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다.
>   이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도,
>   그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다.(전략 패턴)
> - 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고,
>   자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만들었다.(개방/폐쇄 원칙).
> - 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고(낮은 결합도),
>   자신의 책임과 관심사에만 순수하게 집중하는(높은 응집도)
>   깔끔한 코드를 만들 수 있었다.
> - 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘겼다.
>   또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어줬다(제어의 역전/IoC).
> - 전통적인 싱글톤 패턴 구현 방식의 단점을 살펴보고,
>   서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서도 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다(싱글톤 레지스트리).
> - 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고,
>   런타임 시에 실제 사용할 구체적인 의존 오브젝트를 제3자(DI 컨테이너)의 도움으로 주입받아서 다이내믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아봤다(의존관계 주입/DI).
> - 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메소드를 이용하는 방법을 알아봤다(생성자 주입과 수정자 주입).
> - 마지막으로, XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반 값을 외부에서 설정해서 런타입 시에 주입하는 방법을 알아봤다(XML설정).

```
1장을 끝내기 전에,
스프링이란
'어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크'
라는 사실을 꼭 기억해두자.
스프링의 관심은 오브젝트와 그 관계다.
하지만 오브젝트를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 스프링이 아니라 개발자의 역할이며 책임이다.
스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 필연적으로 등장하는 번거로운 작업을 편하게 할 수 있도록 도와주는 도구일 뿐임을 잊지 말자.

스프링을 사용한다고 좋은 객체지향 설계와 깔끔하고 유연한 코드가 저절로 만들어질까? 
그건 절대 아니다.
그 부분은 객체지향 설계와 프로그래밍에 대한 학습과 훈련, 경험이 필요한 부분이며 각자가 공부해야할 책임이 있는 과제다.
다만, 스프링은 그런 좋은 설계와 코드를 적용하고자 할 때 좋은 동반자가 돼 줄 것이다.
```
[처음으로](#토비의-스프링)

# 2장-테스트

```
2장에서는 다음과 같이 테스트의 필요성과 작성 방법을 살펴 봤다.
```

> - 테스트는 자동화되야 하고,
>   빠르게 실행할 수 있어야 한다.
> - main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
> - 테스트 결과는 일관성이 있어야 한다.
>   코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
> - 테스트는 포괄적으로 작성해야 한다.
>   충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
> - 코드 작성과 테스트 수행의 간격이 짧을 수록 효과적이다.
> - 테스트 하기 쉬운 코드가 좋은 코드다.
> - 테스트를 먼저 만들과 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발(TDD) 방법도 유용하다.
> - 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
> - `@Before`, `@After` 를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
> - 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
> - 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
> - `@Autowired` 를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
> - 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
> - 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.

```
스프링을 사용하는 개발자라면 자신이 만든 코드를 테스트로 검증하는 방법을 알고 있어야 하며, 
테스트를 개발에 적극적으로 활용할 수 있어야 한다.
```
[처음으로](#토비의-스프링)

# 3장 - 템플릿
```
3장에서는 예외처리와 안전한 리소스 반환을 보장해주는 DAO 코드를 만들고 이를 객체지향 설계 원리와 디자인 패턴, DI 등을 적용해서 깔끔하고 유연하며 단순한 코드로 만드는 방법을 살펴 봤다.
3장에서 다룬 내용은 다음과 같다.
```

> - JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야 한다.
> - 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다.
>   바뀌지 않는 부분은 컨텍스트로,
>   바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
> - 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
> - 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
> - 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.
> - 컨텍스트는 별도의 빈으로 등록해서 DI 를 받거나 클라이언트 클래스에서 직접 생성해서 사용한다.
>   클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI를 해줄 수 있다.
> - 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고,
>   컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
> - 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.
> - 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
> - 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출 할 수도 있다.
> - 템플릿/콜백을 설계할 떄는 템플릿과 콜백 사이에 주고 받는 정보에 관심을 둬야 한다.

```
템플릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지를 잘 보여주는 예다.
스프링이 제공하는 템플릿/콜백을 잘 사용해야 하는 것은 물론이며 직접 템플릿/콜백을 만들어 활용할 수 도 있어야 한다.
```
[처음으로](#토비의-스프링)
